// MIT

// WARNING: This file has automatically been generated on Mon, 10 Nov 2025 02:26:35 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package herb

/*
#cgo CFLAGS: -I.. -I../src/include -I../src
#cgo LDFLAGS: ${SRCDIR}/../../build/libherb.a ${SRCDIR}/../../vendor/prism/build/libprism.a
#include "herb_go.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// Lextobuffer function as declared in herb/herb_go.h:59
func Lextobuffer(source string, output *hbbuffer) {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	coutput, coutputAllocMap := (*C.hb_buffer_T)(unsafe.Pointer(output)), cgoAllocsUnknown
	C.herb_lex_to_buffer(csource, coutput)
	runtime.KeepAlive(coutputAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
}

// Lex function as declared in herb/herb_go.h:60
func Lex(source string) *hbarray {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	__ret := C.herb_lex(csource)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
	__v := *(**hbarray)(unsafe.Pointer(&__ret))
	return __v
}

// Lexfile function as declared in herb/herb_go.h:61
func Lexfile(path string) *hbarray {
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	__ret := C.herb_lex_file(cpath)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	__v := *(**hbarray)(unsafe.Pointer(&__ret))
	return __v
}

// Parse function as declared in herb/herb_go.h:62
func Parse(source string, options *parseroptions) *ASTDOCUMENTNODE {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	coptions, coptionsAllocMap := (*C.parser_options_T)(unsafe.Pointer(options)), cgoAllocsUnknown
	__ret := C.herb_parse(csource, coptions)
	runtime.KeepAlive(coptionsAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
	__v := *(**ASTDOCUMENTNODE)(unsafe.Pointer(&__ret))
	return __v
}

// Version function as declared in herb/herb_go.h:63
func Version() *byte {
	__ret := C.herb_version()
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Prismversion function as declared in herb/herb_go.h:64
func Prismversion() *byte {
	__ret := C.herb_prism_version()
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Freetokens function as declared in herb/herb_go.h:65
func Freetokens(tokens []*hbarray) {
	ctokens, ctokensAllocMap := (**C.hb_array_T)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tokens)).Data)), cgoAllocsUnknown
	C.herb_free_tokens(ctokens)
	runtime.KeepAlive(ctokensAllocMap)
}

// Extractrubytobuffer function as declared in herb/herb_go.h:68
func Extractrubytobuffer(source string, output *hbbuffer) {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	coutput, coutputAllocMap := (*C.hb_buffer_T)(unsafe.Pointer(output)), cgoAllocsUnknown
	C.herb_extract_ruby_to_buffer(csource, coutput)
	runtime.KeepAlive(coutputAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
}

// Extracthtmltobuffer function as declared in herb/herb_go.h:69
func Extracthtmltobuffer(source string, output *hbbuffer) {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	coutput, coutputAllocMap := (*C.hb_buffer_T)(unsafe.Pointer(output)), cgoAllocsUnknown
	C.herb_extract_html_to_buffer(csource, coutput)
	runtime.KeepAlive(coutputAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
}

// Extractrubywithsemicolons function as declared in herb/herb_go.h:70
func Extractrubywithsemicolons(source string) *byte {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	__ret := C.herb_extract_ruby_with_semicolons(csource)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Extractrubytobufferwithsemicolons function as declared in herb/herb_go.h:71
func Extractrubytobufferwithsemicolons(source string, output *hbbuffer) {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	coutput, coutputAllocMap := (*C.hb_buffer_T)(unsafe.Pointer(output)), cgoAllocsUnknown
	C.herb_extract_ruby_to_buffer_with_semicolons(csource, coutput)
	runtime.KeepAlive(coutputAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
}

// Extract function as declared in herb/herb_go.h:72
func Extract(source string, language herbextractlanguage) *byte {
	source = safeString(source)
	csource, csourceAllocMap := unpackPCharString(source)
	clanguage, clanguageAllocMap := (C.herb_extract_language_T)(language), cgoAllocsUnknown
	__ret := C.herb_extract(csource, clanguage)
	runtime.KeepAlive(clanguageAllocMap)
	runtime.KeepAlive(source)
	runtime.KeepAlive(csourceAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Extractfromfile function as declared in herb/herb_go.h:73
func Extractfromfile(path string, language herbextractlanguage) *byte {
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	clanguage, clanguageAllocMap := (C.herb_extract_language_T)(language), cgoAllocsUnknown
	__ret := C.herb_extract_from_file(cpath, clanguage)
	runtime.KeepAlive(clanguageAllocMap)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Hbarraysize function as declared in herb/herb_go.h:76
func Hbarraysize(array []hbarray) uint64 {
	carray, carrayAllocMap := (*C.hb_array_T)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	__ret := C.hb_array_size(carray)
	runtime.KeepAlive(carrayAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// Hbarrayget function as declared in herb/herb_go.h:77
func Hbarrayget(array []hbarray, index uint64) unsafe.Pointer {
	carray, carrayAllocMap := (*C.hb_array_T)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cindex, cindexAllocMap := (C.ulong)(index), cgoAllocsUnknown
	__ret := C.hb_array_get(carray, cindex)
	runtime.KeepAlive(cindexAllocMap)
	runtime.KeepAlive(carrayAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}
