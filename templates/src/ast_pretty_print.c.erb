#include "include/ast_node.h"
#include "include/ast_nodes.h"
#include "include/ast_pretty_print.h"
#include "include/errors.h"
#include "include/buffer.h"
#include "include/token_struct.h"
#include "include/util.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

void ast_indent(buffer_T* buffer, const size_t indent) {
  for (size_t i = 0; i < indent; i++) {
    buffer_append(buffer, "    ");
  }
}

void ast_pretty_print_newline(const size_t indent, const size_t relative_indent, buffer_T* buffer) {
  ast_indent(buffer, indent);
  ast_indent(buffer, relative_indent);
  buffer_append(buffer, "\n");
}

void ast_pretty_print_label(
  const char* name, const size_t indent, const size_t relative_indent, const bool last_property, buffer_T* buffer
) {
  ast_indent(buffer, indent);
  ast_indent(buffer, relative_indent);

  if (last_property) {
    buffer_append(buffer, "└── ");
  } else {
    buffer_append(buffer, "├── ");
  }

  buffer_append(buffer, name);
  buffer_append(buffer, ": ");
}

void ast_pretty_print_quoted_property(
  const char* name, const char* value, const size_t indent, const size_t relative_indent, const bool last_property,
  buffer_T* buffer
) {
  char* quoted = quoted_string(value);
  ast_pretty_print_property(name, quoted, indent, relative_indent, last_property, buffer);
  free(quoted);
}

void ast_pretty_print_property(
  const char* name, const char* value, const size_t indent, const size_t relative_indent, const bool last_property,
  buffer_T* buffer
) {
  ast_pretty_print_label(name, indent, relative_indent, last_property, buffer);
  buffer_append(buffer, value);
  buffer_append(buffer, "\n");
}

void ast_pretty_print_array(
  const char* name, array_T* array, const size_t indent, const size_t relative_indent, const bool last_property,
  buffer_T* buffer
) {
  if (array == NULL) {
    ast_pretty_print_property(name, "∅", indent, relative_indent, last_property, buffer);

    return;
  }

  if (array_size(array) == 0) {
    ast_pretty_print_property(name, "[]", indent, relative_indent, last_property, buffer);

    return;
  }

  ast_pretty_print_label(name, indent, relative_indent, last_property, buffer);

  buffer_append(buffer, "(");

  char count[16];
  sprintf(count, "%zu", array_size(array));
  buffer_append(buffer, count);
  buffer_append(buffer, ")\n");

  if (indent < 20) {
    for (size_t i = 0; i < array_size(array); i++) {
      AST_NODE_T* child = array_get(array, i);
      ast_indent(buffer, indent);
      ast_indent(buffer, relative_indent + 1);

      if (i == array_size(array) - 1) {
        buffer_append(buffer, "└── ");
      } else {
        buffer_append(buffer, "├── ");
      }

      ast_pretty_print_node(child, indent + 1, relative_indent + 1, buffer);

      if (i != array_size(array) - 1) { ast_pretty_print_newline(indent + 1, relative_indent, buffer); }
    }
  }
}

void ast_pretty_print_errors(
  AST_NODE_T* node, const size_t indent, const size_t relative_indent, const bool last_property, buffer_T* buffer
) {
  if (node->errors != NULL && array_size(node->errors) > 0) {
    error_pretty_print_array("errors", node->errors, indent, relative_indent, last_property, buffer);
  }
}

void ast_pretty_print_locations(location_T* start, location_T* end, buffer_T* buffer) {
  buffer_append(buffer, "(location: (");
  char location[128];
  sprintf(
    location,
    "%zu,%zu)-(%zu,%zu",
    (start && start->line) ? start->line : 0,
    (start && start->column) ? start->column : 0,
    (end && end->line) ? end->line : 0,
    (end && end->column) ? end->column : 0
  );
  buffer_append(buffer, location);
  buffer_append(buffer, "))");
}

void ast_pretty_print_location_property(
  location_T* location, const char* name, const size_t indent, const size_t relative_ident, const bool last_property, buffer_T* buffer
) {
  ast_pretty_print_label(name, indent, relative_ident, last_property, buffer);

  if (location != NULL) {
    buffer_append(buffer, "(");

    char location_string[128];

    sprintf(
      location_string,
      "%zu:%zu",
      (location->line) ? location->line : 0,
      (location->column) ? location->column : 0
    );

    buffer_append(buffer, location_string);
    buffer_append(buffer, ")");
  } else {
    buffer_append(buffer, "∅");
  }

  buffer_append(buffer, "\n");
}

void ast_pretty_print_token_property(
  token_T* token, const char* name, const size_t indent, const size_t relative_ident, const bool last_property, buffer_T* buffer
) {
  ast_pretty_print_label(name, indent, relative_ident, last_property, buffer);

  if (token != NULL && token->value != NULL) {
    char* quoted = quoted_string(token->value);
    buffer_append(buffer, quoted);
    free(quoted);

    buffer_append(buffer, " ");
    ast_pretty_print_locations(token->start, token->end, buffer);
  } else {
    buffer_append(buffer, "∅");
  }

  buffer_append(buffer, "\n");
}

void ast_pretty_print_node(AST_NODE_T* node, const size_t indent, const size_t relative_indent, buffer_T* buffer) {
  if (!node) { return; }

  bool print_locations = true;

  buffer_append(buffer, "@ ");
  buffer_append(buffer, ast_node_human_type(node));
  buffer_append(buffer, " ");

  if (print_locations) { ast_pretty_print_locations(node->start, node->end, buffer); }

  buffer_append(buffer, "\n");

  switch (node->type) {
    <%- nodes.each do |node| -%>
    // TODO: add case for <%= node.name %>
    <%- end -%>

    case AST_HTML_ELEMENT_NODE: {
      const AST_HTML_ELEMENT_NODE_T* element = (AST_HTML_ELEMENT_NODE_T*) node;

      const char* is_void = element->is_void ? "true" : "false";

      ast_pretty_print_token_property(element->tag_name, "tag_name", indent, relative_indent, false, buffer);
      ast_pretty_print_property("is_void", is_void, indent, relative_indent, false, buffer);
      ast_pretty_print_label("open_tag", indent, relative_indent, false, buffer);

      if (element->open_tag) {
        buffer_append(buffer, "\n");
        ast_indent(buffer, indent);
        ast_indent(buffer, relative_indent + 1);

        buffer_append(buffer, "└── ");
        ast_pretty_print_node((AST_NODE_T*) element->open_tag, indent, relative_indent + 2, buffer);
      } else {
        buffer_append(buffer, " ∅\n");
      }

      if (!element->is_void) {
        ast_pretty_print_array("body", element->body, indent, relative_indent, false, buffer);
        ast_pretty_print_label("close_tag", indent, relative_indent, true, buffer);

        if (element->close_tag) {
          buffer_append(buffer, "\n");
          ast_indent(buffer, indent);
          ast_indent(buffer, relative_indent + 1);

          buffer_append(buffer, "└── ");
          ast_pretty_print_node((AST_NODE_T*) element->close_tag, indent, relative_indent + 2, buffer);
        } else {
          buffer_append(buffer, " ∅\n");
        }
      }
    } break;

    case AST_HTML_OPEN_TAG_NODE: {
      const AST_HTML_OPEN_TAG_NODE_T* open_tag = (AST_HTML_OPEN_TAG_NODE_T*) node;

      ast_pretty_print_token_property(
        open_tag->tag_opening,
        "tag_opening",
        indent,
        relative_indent,
        false,
        buffer
      );

      ast_pretty_print_token_property(open_tag->tag_name, "tag_name", indent, relative_indent, false, buffer);

      ast_pretty_print_token_property(
        open_tag->tag_closing,
        "tag_closing",
        indent,
        relative_indent,
        false,
        buffer
      );

      ast_pretty_print_property(
        "is_void",
        open_tag->is_void ? "true" : "false",
        indent,
        relative_indent,
        false,
        buffer
      );

      if (open_tag->attributes) {
        ast_pretty_print_array(
          "attributes",
          open_tag->attributes,
          indent,
          relative_indent,
          false,
          buffer
        );
      } else {
        ast_pretty_print_property("attributes", "∅", indent, relative_indent, true, buffer);
      }

      ast_pretty_print_array("children", open_tag->children, indent, relative_indent, true, buffer);
    } break;

    case AST_HTML_CLOSE_TAG_NODE: {
      const AST_HTML_CLOSE_TAG_NODE_T* close_tag = (AST_HTML_CLOSE_TAG_NODE_T*) node;

      ast_pretty_print_token_property(
        close_tag->tag_opening,
        "tag_opening",
        indent,
        relative_indent,
        false,
        buffer
      );
      ast_pretty_print_token_property(close_tag->tag_name, "tag_name", indent, relative_indent, false, buffer);
      ast_pretty_print_token_property(
        close_tag->tag_closing,
        "tag_closing",
        indent,
        relative_indent,
        true,
        buffer
      );

    } break;

    case AST_HTML_TEXT_NODE: {
      const AST_HTML_TEXT_NODE_T* text_node = (AST_HTML_TEXT_NODE_T*) node;

      const char* value = "∅";
      char* escaped = NULL;
      char* quoted = NULL;

      if (text_node->content != NULL) {
        escaped = escape_newlines(text_node->content);
        quoted = quoted_string(escaped);
        value = quoted;
      }

      ast_pretty_print_property("content", value, indent, relative_indent, true, buffer);

      if (text_node->content != NULL) {
        if (escaped != NULL) { free(escaped); }
        if (quoted != NULL) { free(quoted); }
      }

    } break;

    case AST_HTML_COMMENT_NODE: {
      const AST_HTML_COMMENT_NODE_T* comment = (AST_HTML_COMMENT_NODE_T*) node;

      ast_pretty_print_token_property(
        comment->comment_start,
        "comment_start",
        indent,
        relative_indent,
        false,
        buffer
      );
      ast_pretty_print_token_property(comment->comment_end, "comment_end", indent, relative_indent, false, buffer);

      ast_pretty_print_array("children", comment->children, indent, relative_indent, true, buffer);
    } break;

    case AST_ERB_CONTENT_NODE: {
      const AST_ERB_CONTENT_NODE_T* erb_content_node = (AST_ERB_CONTENT_NODE_T*) node;

      ast_pretty_print_token_property(
        erb_content_node->tag_opening,
        "tag_opening",
        indent,
        relative_indent + 0,
        false,
        buffer
      );
      ast_pretty_print_token_property(
        erb_content_node->content,
        "content",
        indent,
        relative_indent + 0,
        false,
        buffer
      );
      ast_pretty_print_token_property(
        erb_content_node->tag_closing,
        "tag_closing",
        indent,
        relative_indent + 0,
        true,
        buffer
      );
    } break;

    case AST_HTML_ATTRIBUTE_NODE: {
      const AST_HTML_ATTRIBUTE_NODE_T* attribute = (AST_HTML_ATTRIBUTE_NODE_T*) node;

      ast_pretty_print_label("name", indent, relative_indent, false, buffer);

      if (attribute->name) {
        buffer_append(buffer, "\n");
        ast_indent(buffer, indent);
        ast_indent(buffer, relative_indent + 1);

        buffer_append(buffer, "└── ");
        ast_pretty_print_node((AST_NODE_T*) attribute->name, indent, relative_indent + 1, buffer);
      } else {
        buffer_append(buffer, "∅\n");
      }

      ast_pretty_print_token_property(attribute->equals, "equals", indent, relative_indent, false, buffer);

      ast_pretty_print_label("value", indent, relative_indent, true, buffer);

      if (attribute->value) {
        buffer_append(buffer, "\n");
        ast_indent(buffer, indent);
        ast_indent(buffer, relative_indent + 1);

        buffer_append(buffer, "└── ");
        ast_pretty_print_node((AST_NODE_T*) attribute->value, indent, relative_indent + 1, buffer);
      } else {
        buffer_append(buffer, "∅\n");
      }

    } break;

    case AST_HTML_ATTRIBUTE_NAME_NODE: {
      const AST_HTML_ATTRIBUTE_NAME_NODE_T* attribute_name = (AST_HTML_ATTRIBUTE_NAME_NODE_T*) node;

      ast_pretty_print_token_property(attribute_name->name, "name", indent, relative_indent + 1, true, buffer);
    } break;

    case AST_HTML_ATTRIBUTE_VALUE_NODE: {
      const AST_HTML_ATTRIBUTE_VALUE_NODE_T* attribute_value = (AST_HTML_ATTRIBUTE_VALUE_NODE_T*) node;

      ast_pretty_print_token_property(
        attribute_value->open_quote,
        "open_quote",
        indent,
        relative_indent + 1,
        false,
        buffer
      );
      ast_pretty_print_token_property(
        attribute_value->close_quote,
        "close_quote",
        indent,
        relative_indent + 1,
        false,
        buffer
      );

      ast_pretty_print_array("children", attribute_value->children, indent, relative_indent + 1, true, buffer);
    } break;

    case AST_DOCUMENT_NODE: {
      const AST_DOCUMENT_NODE_T* document_node = (AST_DOCUMENT_NODE_T*) node;
      ast_pretty_print_array("children", document_node->children, indent, 0, true, buffer);
    } break;

    case AST_HTML_DOCTYPE_NODE: {
      AST_HTML_DOCTYPE_NODE_T* doctype = (AST_HTML_DOCTYPE_NODE_T*) node;

      ast_pretty_print_token_property(doctype->tag_opening, "tag_opening", indent, relative_indent, false, buffer);
      ast_pretty_print_token_property(doctype->tag_closing, "tag_closing", indent, relative_indent, false, buffer);

      ast_pretty_print_array("children", doctype->children, indent, relative_indent, true, buffer);
    } break;

    case AST_LITERAL_NODE: {
      const AST_LITERAL_NODE_T* literal = (AST_LITERAL_NODE_T*) node;
      char* quoted = quoted_string(literal->content);
      ast_pretty_print_property(
        "content",
        quoted,
        indent,
        relative_indent,
        true,
        buffer
      );
      free(quoted);
    } break;

    case AST_HTML_SELF_CLOSE_TAG_NODE:
    case AST_WHITESPACE_NODE: {
      // TODO:
    } break;
  }

  ast_pretty_print_errors(node, indent, relative_indent, true, buffer);
}
