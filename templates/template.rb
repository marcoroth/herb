# frozen_string_literal: true

require "erb"
require "fileutils"
require "yaml"

module ERBX
  module Template
    class Field
      attr_reader :name, :options

      def initialize(name:, **options)
        @name = name
        @options = options
      end
    end

    class ArrayField < Field
      def initialize(kind:, **options)
        @kind = kind
        super(**options)
      end

      def ruby_type
        "Array"
      end

      def c_type
        "array_T*"
      end

      def ruby_item_type
        specific_kind || "Object"
      end

      def c_item_type
        if specific_kind
          "AST_#{specific_kind.gsub(/(?<=[a-zA-Z])(?=[A-Z][a-z])/, "_").upcase}_T*"
        else
          "void*"
        end
      end

      def specific_kind
        @kind unless @kind.is_a?(Array)
      end

      def union_kind
        @kind if @kind.is_a?(Array)
      end
    end

    class NodeField < Field
      def initialize(kind:, **options)
        @kind = kind
        super(**options)
      end

      def c_type
        if specific_kind
          "AST_#{specific_kind.gsub(/(?<=[a-zA-Z])(?=[A-Z][a-z])/, "_").upcase}_T*"
        else
          "AST_NODE_T*"
        end
      end

      def ruby_type
        specific_kind || "Node"
      end

      def specific_kind
        @kind unless @kind.is_a?(Array)
      end

      def union_kind
        @kind if @kind.is_a?(Array)
      end
    end

    class TokenField < Field
      def ruby_type
        "ERBX::Token"
      end

      def c_type
        "token_T*"
      end
    end

    class StringField < Field
      def ruby_type
        "String"
      end

      def c_type
        "char*"
      end
    end

    class LocationField < Field
      def ruby_type
        "ERBX::Location"
      end

      def c_type
        "location_T*"
      end
    end

    class IntegerField < Field
      def ruby_type
        "Integer"
      end

      def c_type
        "int"
      end
    end

    class SizeTField < Field
      def ruby_type
        "Integer"
      end

      def c_type
        "size_t"
      end
    end

    class BooleanField < Field
      def ruby_type
        "TrueClass |Â FalseClass"
      end

      def c_type
        "bool"
      end
    end

    class NodeType
      attr_reader :name, :type, :struct_type, :human, :fields

      def initialize(config)
        @name = config.fetch("name")
        camelized = @name.gsub(/(?<=[a-zA-Z])(?=[A-Z][a-z])/, "_")
        @type = "AST_#{camelized.upcase}"
        @struct_type = "AST_#{camelized.upcase}_T"
        @human = camelized.downcase

        @fields = config.fetch("fields", []).map do |field|
          field_name = field.fetch("name")
          type = field_type_for(field.fetch("type"))
          kind = normalize_kind(field.fetch("kind", nil), type, @name, field_name)

          type.new(name: field_name, kind: kind)
        end
      end

      private

      def normalize_kind(kind, type, name, field_name)
        if kind
          kind = [kind] unless kind.is_a?(Array)

          if kind.size == 1
            kind = kind.first
            kind = nil if kind == "Node"
          end
        elsif type < NodeField
          raise "Missing kind in config.yml for field #{name}##{field_name}"
        end

        kind
      end

      def field_type_for(name)
        case name
        when "array"     then ArrayField
        when "node"      then NodeField
        when "token"     then TokenField
        when "string"    then StringField
        when "location"  then LocationField
        when "size_t"    then SizeTField
        when "boolean"   then BooleanField
        else raise("Unknown field type: #{name.inspect}")
        end
      end
    end

    def self.heading_for(file, template_file)
      case File.extname(file)
      when ".rb"
        <<~HEADING
          # frozen_string_literal: true

          # NOTE: This file is generated by the templates/template.rb script and should not be
          # modified manually. See #{template_file}

        HEADING
      else
        <<~HEADING
          // NOTE: This file is generated by the templates/template.rb script and should not
          // be modified manually. See #{template_file}

        HEADING
      end
    end

    def self.check_gitignore(name)
      return if gitignore_lines.include?(name)

      puts "[WARNING]: make sure to add `#{name}` to the `.gitignore`"
      puts
    end

    def self.render(template_file)
      name = template_file.delete_prefix("templates/").delete_suffix(".erb")
      template_path = File.expand_path("../#{template_file}", __dir__)
      destination = File.expand_path("../#{name}", __dir__)

      rendered_template = read_template(template_path).result_with_hash({ nodes: nodes })
      content = heading_for(name, template_file) + rendered_template

      check_gitignore(name)

      FileUtils.mkdir_p(File.dirname(destination))
      File.write(destination, content)
    rescue SyntaxError => e
      puts
      puts "Error while rendering #{template_file}:"
      puts e
      puts
    end

    def self.read_template(path)
      content = File.read(path, encoding: Encoding::UTF_8)

      ERB.new(content, trim_mode: "-").tap do |erb|
        erb.filename = path
      end
    end

    def self.gitignore_lines
      @gitignore_lines ||= File.readlines(".gitignore").map(&:chomp)
    end

    def self.nodes
      @nodes ||= config.fetch("nodes", []).map { |node| NodeType.new(node) }
    end

    def self.config
      @config ||= YAML.load_file("config.yml")
    end
  end
end
